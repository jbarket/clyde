<!-- Generated by clyde v1.0.0 on 2025-07-30 11:02:40 -->
<!-- Target: Claude Specific -->
<!-- Config Hash: ca424fbc -->

# Claude-Specific Guidelines

This file contains development standards specific to Claude.

**âš  Do not edit this file directly.** Changes will be overwritten.

# Claude Artifacts Usage Guidelines

## When to Use Artifacts

### Code Files
Create artifacts for:
- **Complete files** that are substantial (>20 lines)
- **Configuration files** that user will likely want to copy
- **Scripts** that user needs to save and execute
- **Data structures** like JSON, YAML, or XML that are reusable

### Documentation
Create artifacts for:
- **README files** or comprehensive documentation
- **API documentation** or interface specifications  
- **Process documentation** that serves as reference
- **Troubleshooting guides** with multiple steps

### Interactive Content
Create artifacts for:
- **Demos or examples** user might want to modify
- **Templates** for user customization
- **Playground code** for experimentation

## When NOT to Use Artifacts

### Simple Responses
Avoid artifacts for:
- **Code snippets** under 20 lines
- **Single commands** or one-liners
- **Brief explanations** or answers
- **Simple examples** that are illustrative only

### Conversational Context
Avoid artifacts for:
- **Inline code** within explanations
- **Error messages** or debugging output
- **Configuration snippets** that are part of larger discussion
- **Examples** that don't warrant separate files

## Artifact Naming and Organization

### File Naming Conventions
```bash
# Good artifact names
user-service.py
authentication-config.yaml
deployment-guide.md
api-client-example.js

# Bad artifact names
code.py
config.txt
file.md
example.js
```

### Content Organization
- Use **clear file extensions** that match content type
- **Structure content** logically with proper headers
- **Include comments** in code artifacts for clarity
- **Add usage instructions** when helpful

## Best Practices

### Code Artifacts
```python
# Good: Complete, runnable file with comments
# user_service.py
"""
User service for handling authentication and user management.
"""

class UserService:
    def __init__(self, database_url: str):
        """Initialize user service with database connection."""
        self.db_url = database_url
    
    def authenticate_user(self, username: str, password: str) -> bool:
        """Authenticate user credentials."""
        # Implementation here
        pass
```

### Configuration Artifacts
```yaml
# Good: Complete configuration with comments
# docker-compose.yml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://localhost/myapp
    depends_on:
      - database
  
  database:
    image: postgres:13
    environment:
      - POSTGRES_DB=myapp
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
```

### Documentation Artifacts
```markdown
# API Integration Guide

## Setup
1. Install the client library: `npm install api-client`
2. Configure your API key in environment variables
3. Initialize the client in your application

## Authentication
Use the API key authentication method...

## Common Endpoints
- GET /users - List all users
- POST /users - Create new user
- PUT /users/:id - Update user
```

## Integration with Development Workflow

### Version Control Considerations
- Create artifacts that work well with git
- Use consistent formatting for diffs
- Include proper file headers when appropriate
- Structure for easy code review

### Team Collaboration
- Make artifacts self-documenting
- Include setup/usage instructions
- Use standard project conventions
- Consider artifact reusability across team

### Maintenance
- Keep artifacts up-to-date with project evolution
- Remove outdated artifacts when no longer relevant
- Update artifact content when dependencies change
- Ensure artifacts follow current project standards

# Claude Model Strategy

**Core:** Strategic approach to Claude model selection, prompting techniques, and capability optimization.

## Model Selection Strategy

### Model Capabilities by Type
- **Claude 3.5 Sonnet**: Best for complex reasoning, coding, analysis
- **Claude 3 Haiku**: Fastest response, simple tasks, high-volume operations  
- **Claude 3 Opus**: Most capable for creative work, complex analysis

### Selection Criteria
```python
def select_claude_model(task_type, complexity, response_time_priority):
    if complexity == "high" and task_type in ["analysis", "coding", "reasoning"]:
        return "claude-3-5-sonnet"
    elif response_time_priority == "critical" or task_type == "simple":
        return "claude-3-haiku"
    elif task_type in ["creative", "research", "complex_analysis"]:
        return "claude-3-opus"
    else:
        return "claude-3-5-sonnet"  # Default balanced choice
```

## Prompting Strategies

### Structured Prompting
```markdown
# Task: [Clear, specific task description]

## Context:
[Relevant background information]

## Requirements:
- Requirement 1
- Requirement 2
- Requirement 3

## Output Format:
[Specify exact format needed]

## Examples:
[1-2 concrete examples if helpful]
```

### Few-Shot Learning
```markdown
Here are examples of the task:

Input: "Calculate compound interest"
Output: ```python
def compound_interest(principal, rate, time, frequency=1):
    return principal * (1 + rate/frequency)**(frequency * time)
```

Input: "Validate email format"
Output: ```python
import re
def validate_email(email):
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(pattern, email) is not None
```

Now do the same for: [Your actual request]
```

### Chain of Thought
```markdown
Solve this step by step:

1. First, identify what we need to find
2. Then, break down the problem into smaller parts
3. Solve each part systematically
4. Combine the results
5. Verify the solution makes sense

Problem: [Your problem here]
```

## Context Window Management

### Context Optimization
```python
def optimize_context_for_claude(content, max_tokens=200000):
    """Optimize content to fit within Claude's context window"""
    
    # Priority order for content inclusion
    priority_sections = [
        "current_task",
        "recent_context", 
        "code_examples",
        "documentation",
        "historical_context"
    ]
    
    optimized_content = []
    token_count = 0
    
    for section in priority_sections:
        section_content = content.get(section, "")
        section_tokens = estimate_tokens(section_content)
        
        if token_count + section_tokens <= max_tokens:
            optimized_content.append(section_content)
            token_count += section_tokens
        else:
            # Truncate or summarize if needed
            remaining_tokens = max_tokens - token_count
            truncated = truncate_intelligently(section_content, remaining_tokens)
            optimized_content.append(truncated)
            break
    
    return "\n\n".join(optimized_content)
```

### Information Hierarchy
1. **Critical Context** (current task, immediate requirements)
2. **Supporting Context** (relevant code, recent changes)
3. **Reference Material** (documentation, examples)
4. **Background Information** (project history, decisions)

## Advanced Techniques

### System Message Optimization
```python
SYSTEM_MESSAGES = {
    "coding": """You are an expert software engineer focused on writing clean, 
    efficient, and maintainable code. Always consider:
    - Code readability and documentation
    - Error handling and edge cases
    - Performance implications
    - Security best practices""",
    
    "analysis": """You are a technical analyst. Provide thorough, evidence-based 
    analysis with:
    - Clear reasoning for conclusions
    - Identification of assumptions
    - Alternative perspectives considered
    - Actionable recommendations""",
    
    "debugging": """You are a debugging expert. Approach problems systematically:
    - Gather all relevant information
    - Form hypotheses about root causes
    - Suggest specific debugging steps
    - Provide multiple solution approaches"""
}
```

### Response Format Control
```python
def format_claude_response(task_type):
    formats = {
        "code_review": """
        ## Summary
        [Brief overview of findings]
        
        ## Issues Found
        ### Critical
        - Issue 1: Description and fix
        
        ### Minor
        - Issue 1: Description and suggestion
        
        ## Recommendations
        - Recommendation 1
        - Recommendation 2
        """,
        
        "technical_analysis": """
        ## Analysis
        [Main findings]
        
        ## Key Points
        1. Point 1
        2. Point 2
        
        ## Recommendations
        - Action 1
        - Action 2
        
        ## Next Steps
        - Step 1
        - Step 2
        """
    }
    return formats.get(task_type, "")
```

## Code Generation Strategies

### Iterative Refinement
```markdown
1. **Initial Implementation**: Create basic working version
2. **Error Handling**: Add comprehensive error handling  
3. **Optimization**: Improve performance and efficiency
4. **Documentation**: Add comments and docstrings
5. **Testing**: Include test cases and edge cases
```

### Code Quality Prompts
```markdown
Generate production-ready code that includes:
- Type hints (Python/TypeScript)
- Comprehensive error handling
- Input validation
- Clear documentation
- Unit test examples
- Performance considerations
- Security best practices

Code should be:
- Readable and maintainable
- Following language-specific conventions
- Properly structured and organized
- Ready for code review
```

## Multi-Turn Conversations

### Context Continuity
```python
class ClaudeConversationManager:
    def __init__(self):
        self.conversation_history = []
        self.context_summary = ""
        
    def add_exchange(self, user_message, claude_response):
        self.conversation_history.append({
            "user": user_message,
            "claude": claude_response,
            "timestamp": datetime.now()
        })
        
        # Summarize if history gets too long
        if len(self.conversation_history) > 10:
            self.summarize_early_context()
    
    def get_context_for_next_message(self):
        recent_context = self.conversation_history[-5:]  # Last 5 exchanges
        
        context = f"""
        Previous conversation summary: {self.context_summary}
        
        Recent exchanges:
        """
        
        for exchange in recent_context:
            context += f"User: {exchange['user']}\n"
            context += f"Claude: {exchange['claude'][:200]}...\n\n"
        
        return context
```

### State Management
```python
def maintain_conversation_state(conversation_id, new_context):
    """Maintain state across multiple interactions"""
    
    state = {
        "active_task": extract_current_task(new_context),
        "code_context": extract_code_references(new_context),
        "decisions_made": extract_decisions(new_context),
        "preferences": extract_user_preferences(new_context)
    }
    
    # Store state for next interaction
    save_conversation_state(conversation_id, state)
    return state
```

## Performance Optimization

### Response Quality Metrics
```python
def evaluate_claude_response(response, task_type):
    metrics = {
        "completeness": check_requirements_met(response),
        "accuracy": verify_technical_correctness(response),
        "clarity": assess_explanation_quality(response),
        "actionability": check_actionable_recommendations(response)
    }
    
    if task_type == "coding":
        metrics.update({
            "code_quality": analyze_code_quality(response),
            "best_practices": check_best_practices(response)
        })
    
    return metrics
```

### Prompt Optimization
```python
def optimize_prompt_for_task(base_prompt, task_context, previous_results=None):
    """Iteratively improve prompts based on results"""
    
    optimizations = []
    
    if previous_results and previous_results.get("accuracy") < 0.8:
        optimizations.append("Be more specific about technical requirements")
    
    if previous_results and previous_results.get("completeness") < 0.8:
        optimizations.append("Include step-by-step breakdown")
    
    if task_context.get("complexity") == "high":
        optimizations.append("Use chain-of-thought reasoning")
    
    optimized_prompt = base_prompt
    for optimization in optimizations:
        optimized_prompt = apply_optimization(optimized_prompt, optimization)
    
    return optimized_prompt
```

## Error Handling and Recovery

### Common Issues and Solutions
```python
CLAUDE_ERROR_PATTERNS = {
    "context_overflow": {
        "symptom": "Response mentions context limits",
        "solution": "Reduce context size, prioritize recent information"
    },
    "unclear_requirements": {
        "symptom": "Response asks for clarification",
        "solution": "Provide more specific requirements and examples"
    },
    "incomplete_response": {
        "symptom": "Response cuts off mid-sentence",
        "solution": "Ask Claude to continue from where it left off"
    }
}

def handle_claude_error(response, original_prompt):
    for error_type, pattern in CLAUDE_ERROR_PATTERNS.items():
        if detect_pattern(response, pattern["symptom"]):
            return apply_solution(original_prompt, pattern["solution"])
    
    return original_prompt  # No specific error detected
```

## Integration Patterns

### API Integration
```python
class ClaudeAPIWrapper:
    def __init__(self, api_key, model="claude-3-5-sonnet"):
        self.client = anthropic.Anthropic(api_key=api_key)
        self.model = model
    
    async def generate_response(self, prompt, system_message=None, max_tokens=4000):
        try:
            response = await self.client.messages.create(
                model=self.model,
                max_tokens=max_tokens,
                system=system_message,
                messages=[{"role": "user", "content": prompt}]
            )
            return response.content[0].text
        except Exception as e:
            logger.error(f"Claude API error: {e}")
            return self.fallback_response(prompt)
    
    def fallback_response(self, prompt):
        return "I apologize, but I'm unable to process your request at the moment. Please try again."
```

## Best Practices Summary

### Prompting
- **Be specific** about requirements and output format
- **Provide context** relevant to the task
- **Use examples** when appropriate
- **Structure prompts** clearly with headers and sections

### Model Selection
- **Sonnet** for most development tasks
- **Haiku** for simple, fast operations
- **Opus** for complex creative or analytical work

### Context Management
- **Prioritize recent** and relevant information
- **Summarize older** context when needed
- **Maintain conversation** state across interactions
- **Monitor token usage** to avoid context overflow

### Quality Assurance
- **Test responses** against requirements
- **Iterate on prompts** based on results
- **Handle errors** gracefully with fallbacks
- **Measure performance** and optimize continuously

# Claude-Specific Formatting Guidelines

## Response Style

### Conciseness Standards
- **Primary rule**: Answer concisely with fewer than 4 lines of text unless detail is requested
- **Minimize tokens** while maintaining helpfulness and accuracy
- **One-word answers** are preferred when appropriate
- **Avoid preamble/postamble** unless specifically requested

### Examples of Appropriate Conciseness
```
User: "2 + 2"
Claude: "4"

User: "What command lists files?"
Claude: "ls"

User: "Is 11 prime?"
Claude: "Yes"
```

### Code Explanation Guidelines
- **Do not add code explanations** unless user explicitly requests them
- **After editing files**: Stop rather than explaining what was done
- **Focus on the task**: Answer directly without elaboration

## Tone and Communication

### Professional Directness
- Be direct and to-the-point
- Avoid unnecessary pleasantries
- Focus on solving the problem efficiently
- Maintain professional but efficient communication

### Appropriate Verbosity Levels
```bash
# Minimal responses for simple queries
User: "How to install npm packages?"
Claude: "npm install"

# Detailed responses when explicitly requested
User: "Explain in detail how npm install works"
Claude: [Provides comprehensive explanation]
```

## Output Formatting

### Command Line Interface Considerations
- Responses displayed on CLI with monospace font
- Use GitHub-flavored markdown for formatting
- Keep line lengths reasonable for terminal display
- Structure content for easy terminal reading

### Code Blocks and Examples
```bash
# Use clear, executable examples
npm install express
git commit -m "Add user authentication"
python manage.py migrate
```

### Error Communication
- State errors clearly without excessive explanation
- Provide fix suggestions immediately
- Avoid lengthy error analysis unless requested

## Tool Usage Communication

### Bash Commands
- Explain what non-trivial commands do before execution
- Ensure user understands system-affecting operations
- Use clear descriptions for command purposes

### File Operations
- Mention file changes when significant
- Don't over-explain routine file operations
- Focus on the outcome rather than the process

## Anti-Patterns to Avoid

### Excessive Verbosity
```bash
# Bad: Unnecessary explanation
"I'm going to help you with this task. First, let me analyze what you're asking for..."

# Good: Direct action
[Performs the requested action]
```

### Unnecessary Summaries
```bash
# Bad: Post-action summary
"I've successfully updated the configuration file by adding the new environment variables and ensuring proper formatting."

# Good: Completion confirmation
"Updated config.yaml with new environment variables"
```

### Over-Qualification
```bash
# Bad: Excessive hedging
"This should probably work, and I believe it might solve your issue, though there could be edge cases..."

# Good: Direct statement
"This will fix the authentication error"
```

## Context-Aware Responses

### User Expertise Level
- Adapt response detail to demonstrated user knowledge
- Avoid explaining basic concepts to experienced developers
- Provide more guidance for complex operations

### Task Complexity Matching
- Simple tasks get simple responses
- Complex tasks warrant detailed explanation
- Match response complexity to problem complexity

### Follow-up Efficiency
- Anticipate likely follow-up questions
- Provide actionable next steps when appropriate
- Avoid creating dependency on additional explanations