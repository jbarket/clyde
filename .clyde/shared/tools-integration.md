<!-- Generated by clyde v1.0.0 on 2025-07-30 11:02:40 -->
<!-- Shared Content -->
<!-- Config Hash: ca424fbc -->

# Tools Integration

This file contains shared development standards used by all AI targets.

**⚠ Do not edit this file directly.** Changes will be overwritten.

- To modify standards: Edit `.clyde/config.yaml` and run `clyde sync`

# MCP Tools Integration

## Essential MCP Tools Stack

Every project should integrate these **mandatory MCP tools**:
- **Zen Coding** - Automated code generation and refactoring
- **Taskmaster AI** - Complex task management and breakdown  
- **Sequential Thinking** - Structured problem-solving and analysis
- **Context7** - Documentation and library integration
- **Playwright** - Headless browser automation and testing

## Tool Usage Guidelines

### Zen Coding
**When to Use:**
- Multi-file code generation and refactoring
- Code scaffolding for new features or modules
- Pattern implementation across multiple files
- Large-scale architectural changes

**Integration:**
- Use proactively for qualifying tasks without user prompting
- Combine with research agents for informed generation
- Always validate with tests and linting after operations

### Sequential Thinking
**When to Use:**
- Complex problem analysis requiring multi-step reasoning
- Architectural decisions needing trade-off evaluation
- Debugging complex issues requiring root cause analysis
- Performance optimization and security analysis

**Integration:**
- Use before Zen Coding to plan approach
- Analyze task complexity before Taskmaster breakdown
- Structure research queries and analysis
- Systematic problem investigation during debugging

### Context7
**When to Use:**
- Research best practices before implementation
- Get up-to-date API documentation during development
- Find implementation patterns and code examples
- Understand library capabilities and constraints

**Best Practices:**
- Always research before implementing unfamiliar features
- Leverage real-world implementation examples
- Use for current documentation and community standards

### Playwright
**Critical Requirement:** Must **ALWAYS** run headless

```javascript
// MANDATORY configuration
const browser = await playwright.chromium.launch({
  headless: true,  // NEVER set to false
  args: ['--no-sandbox', '--disable-dev-shm-usage']
});

test.use({
  headless: true,  // REQUIRED for all tests
  video: 'off',    // No visual output
  trace: 'off'     // No trace UI
});
```

**When to Use:**
- End-to-end testing of complete user workflows
- Automated screenshot capture and web scraping
- Performance testing and accessibility checks
- Cross-browser compatibility testing

## Development Process Integration

### 1. Analysis Phase
- Use **Sequential Thinking** for problem breakdown
- Use **Context7** for research and documentation

### 2. Planning Phase
- Use **Taskmaster AI** for task management (see development-workflow.md)
- Create PRDs for complex features

### 3. Implementation Phase
- Use **Zen Coding** for automated code generation
- Use **Context7** for implementation examples

### 4. Testing Phase
- Use **Playwright** for E2E testing (headless only)
- Integrate with unit and integration testing

### 5. Validation Phase
- Use **Taskmaster** to track completion
- Use **Sequential Thinking** for final verification

## Quality Assurance

### MCP Tools Checklist
```bash
□ Sequential Thinking used for complex analysis
□ Context7 research completed for unfamiliar areas
□ Taskmaster tracking active for multi-step tasks
□ Zen Coding used for appropriate code generation
□ Playwright E2E tests running headless only
□ All MCP tool outputs validated and tested
```

## Configuration

### Environment Setup
```yaml
# .mcp-config.yaml
tools:
  zen_coding:
    enabled: true
    auto_format: true
    follow_conventions: true
    
  taskmaster:
    enabled: true
    prefer_prd: true
    complexity_analysis: true
    
  sequential_thinking:
    enabled: true
    auto_trigger: complex_analysis
    
  context7:
    enabled: true
    research_first: true
    
  playwright:
    enabled: true
    headless_only: true
    no_interruption: true
```

## Benefits

### Development Efficiency
- Automated code generation reduces repetitive work
- Structured task management improves project organization
- Research integration ensures informed decisions
- Comprehensive testing with headless automation

### Quality Assurance
- Systematic analysis through sequential thinking
- Current documentation via Context7 research
- Tracked progress through Taskmaster management
- Consistent patterns via Zen Coding automation

# Development Workflow

## Git Repository Requirements

### Mandatory Git Setup
- **Every project must have Git repository** - no exceptions
- Initialize immediately: `git init` at project start
- Set up remote repository for backup/collaboration
- Configure `.gitignore` for technology stack

### Strict Feature Branch Workflow
```
main          # Production-ready code ONLY
feature/*     # ALL development happens here
hotfix/*      # Critical production fixes
```
**Critical Rule**: **Never commit directly to main branch**

### Branch Naming
- `feature/user-authentication`
- `bugfix/login-validation-error`
- `hotfix/security-vulnerability`

### Branch Management
```bash
# Always branch from main
git checkout main && git pull origin main
git checkout -b feature/new-feature

# Keep updated
git rebase main

# Delete after merge
git branch -d feature/new-feature
```

## Code Completion Requirements

### Definition of Done
Before any merge to main, code must be **100% complete**:

#### Linting (Zero Tolerance)
```bash
npm run lint           # JavaScript/TypeScript
pylint src/           # Python  
prettier --check .    # JavaScript/TypeScript
black --check .       # Python
```

#### Testing Requirements
```bash
npm test              # JavaScript/TypeScript
pytest               # Python
jest --coverage       # 80%+ coverage
pytest --cov=src     # 80%+ coverage
```

#### Quality Gate Checklist
```bash
□ Linting: 0 errors, 0 warnings
□ Tests: 100% passing
□ Coverage: 80%+ (project standards)
□ Build: Successful in CI/CD
□ Code Review: Approved
□ Documentation: Updated if needed
□ No console errors/debugging statements
```

## Task Management Strategy

### Task Management Hierarchy
**Preference Order:**
1. **PRD + Taskmaster AI** - Complex, multi-step development tasks
2. **Taskmaster breakdown** - Tasks requiring structured planning/tracking
3. **Simple internal todos** - Only trivial, single-step operations

### Decision Matrix
```
Task Complexity               | Recommended Approach
------------------------------|------------------------------------
Multi-step feature            | PRD + Taskmaster AI
Architectural changes         | PRD + Taskmaster AI  
Complex bug investigation     | Taskmaster breakdown
Performance optimization      | PRD + Taskmaster AI
Security implementation       | PRD + Taskmaster AI
Integration projects          | PRD + Taskmaster AI
------------------------------|------------------------------------
Single file edits            | Simple todos
Configuration changes         | Simple todos
Documentation updates         | Simple todos
Simple bug fixes             | Simple todos
```

### When to Use Simple Todos
```markdown
✅ Acceptable:
- Single file edits (config values)
- Adding import statement
- Fixing typo/formatting
- Adding comment/docstring
- Updating version number
- Simple variable rename in one function

❌ Avoid For:
- Multi-file changes
- Feature implementation
- Bug investigation
- Performance optimization
- Security changes
- Database schema changes
- API endpoint creation
- Complex refactoring
- Integration tasks
```

## PRD-Driven Development

### PRD Template Structure
```markdown
# [Feature Name] - Product Requirements Document

## Executive Summary
Brief overview of feature/project and business value.

## Problem Statement
- What problem are we solving?
- Who experiences this problem?
- Impact of not solving it?

## Success Criteria
- How will we measure success?
- Key metrics?
- What does "done" look like?

## Requirements

### Functional Requirements
1. **Core Feature**
   - Specific requirement with acceptance criteria
   - Clear inputs/outputs
   - Edge cases/error handling

### Non-Functional Requirements
- **Performance**: Specific metrics/targets
- **Security**: Requirements/compliance
- **Scalability**: Load/capacity requirements
- **Availability**: Uptime/reliability targets

## Technical Specifications

### Architecture Overview
- High-level system design
- Technology stack decisions
- Integration points

### Implementation Plan
- **Phase 1**: Core functionality (timeline)
- **Phase 2**: Enhanced features (timeline)
- **Phase 3**: Optimization/scaling (timeline)

## Testing Strategy
- **Unit Tests**: Component-level testing
- **Integration Tests**: Module boundary testing
- **End-to-End Tests**: Complete workflow testing

## Acceptance Criteria
- **User Stories**: User-focused acceptance criteria
- **Technical Criteria**: Performance/quality requirements
```

### Taskmaster Workflow
1. **Create comprehensive PRD** following template
2. **Initialize Taskmaster project** with PRD document
3. **Parse PRD into tasks** using Taskmaster AI
4. **Analyze task complexity** and expand complex tasks
5. **Track implementation progress** through status system

### Taskmaster Configuration
```bash
# Initialize project with PRD
tm init --project-root /path/to/project

# Parse PRD into tasks
tm parse-prd --input .taskmaster/docs/prd.txt --num-tasks 0 --research

# Analyze complexity and expand tasks
tm analyze-complexity --threshold 5 --research
tm expand-all --research

# Track progress
tm next-task
tm set-status 1 in-progress
tm update-task 1 "Implementing user model with validation"
```

## Pull Request Process

### Strict Workflow
1. **Feature Branch Complete** - meets all quality gates
2. **Create Pull Request** with comprehensive description
3. **Automated Checks** - CI/CD pipeline must pass
4. **Code Review** - at least one approval required
5. **Address ALL Feedback** - no quality compromises
6. **Final Validation** - re-run all checks
7. **Squash Merge** - maintain clean history
8. **Delete Branch** - clean up immediately

### Pull Request Template
```markdown
## Description
Brief description of changes

## Type of Change
- [ ] Bug fix / [ ] New feature / [ ] Breaking change / [ ] Documentation

## Quality Checklist
- [ ] Linting passes (0 errors, 0 warnings)
- [ ] All tests pass
- [ ] Coverage requirements met
- [ ] No console errors/warnings
- [ ] Documentation updated

## Testing
- [ ] Unit tests added/updated
- [ ] Integration tests added/updated
- [ ] Manual testing completed
```

## Commit Message Standards

### Format
```
type(scope): subject

<body>
<footer>
```

### Types
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation changes
- `style`: Code style changes
- `refactor`: Code refactoring
- `test`: Adding/updating tests
- `chore`: Maintenance tasks

### Examples
```
feat(auth): add JWT token authentication
fix(api): handle null values in user endpoint
docs(readme): update installation instructions
refactor(utils): extract validation functions
```

## Research Integration

### Research-Driven Development
```bash
# Research before PRD creation
tm research "authentication best practices JWT bcrypt security" --save-to-file

# Research architectural patterns
tm research "user authentication microservices architecture" --task-ids 1,2,3

# Research implementation approaches
tm research "bcrypt vs argon2 password hashing" --save-to 1.2
```

### Research Questions for PRDs
```markdown
1. **Industry Standards**: Current best practices for this domain
2. **Security Considerations**: Latest security recommendations
3. **Performance Benchmarks**: Realistic performance targets
4. **Architectural Patterns**: Proven patterns for this problem
5. **Technology Choices**: Pros/cons of implementation options
6. **Compliance Requirements**: Regulations/standards to meet
```

## Key Benefits

### Development Efficiency
- **Clear roadmaps** reduce uncertainty/decision fatigue
- **Structured breakdown** makes large projects manageable
- **Progress tracking** provides development status visibility
- **Research integration** ensures informed decisions

### Quality Improvement
- **Comprehensive planning** reduces overlooked requirements
- **Systematic approach** minimizes technical debt
- **Clear acceptance criteria** improve testing effectiveness
- **Documentation** facilitates knowledge transfer/maintenance

# Git Best Practices

## Commit Guidelines

### Commit Message Format
```
type(scope): subject

<optional body>

<optional footer>
```

### Types
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation changes
- `style`: Code style changes (formatting, etc.)
- `refactor`: Code refactoring
- `test`: Adding or updating tests
- `chore`: Maintenance tasks

### Examples
```
feat(auth): add JWT token authentication

fix(api): handle null values in user endpoint

docs(readme): update installation instructions

refactor(utils): extract validation functions
```

## Branching Strategy

### Mandatory Git Repository
- **Every project must have a Git repository** - no exceptions
- Initialize immediately: `git init` at project start
- Set up remote repository for backup and team collaboration
- Configure appropriate `.gitignore` for technology stack

### Strict Feature Branch Workflow
```
main          # Production-ready code ONLY
feature/*     # ALL development happens here
hotfix/*      # Critical production fixes
```

**Critical Rule**: **Never commit directly to main branch**

### Branch Naming
- `feature/user-authentication`
- `feature/payment-processing`
- `bugfix/login-validation-error`
- `hotfix/security-vulnerability`

### Branch Creation and Management
```bash
# Always branch from main
git checkout main
git pull origin main
git checkout -b feature/new-feature

# Work in feature branch
git add .
git commit -m "feat: implement user authentication"

# Keep feature branch updated
git checkout main
git pull origin main
git checkout feature/new-feature
git rebase main

# Delete after merge
git branch -d feature/new-feature
```

## Code Completion Requirements

### Definition of Done
Before any merge to main, code must be **100% complete**:

#### Linting (Zero Tolerance)
```bash
# Must pass without errors or warnings
npm run lint           # JavaScript/TypeScript
pylint src/           # Python  
cargo clippy          # Rust
golangci-lint run     # Go

# Formatting must be consistent
prettier --check .    # JavaScript/TypeScript
black --check .       # Python
rustfmt --check       # Rust
go fmt ./...          # Go
```

#### Testing Requirements
```bash
# All tests must pass
npm test              # JavaScript/TypeScript
pytest               # Python
cargo test           # Rust
go test ./...        # Go

# Coverage requirements
jest --coverage       # JavaScript (80%+ coverage)
pytest --cov=src     # Python (80%+ coverage)
```

#### Quality Gate Checklist
```bash
# Pre-merge requirements - ALL must pass
□ Linting: 0 errors, 0 warnings
□ Tests: 100% passing
□ Coverage: Meets project standards (typically 80%+)
□ Build: Successful in CI/CD
□ Code Review: Approved by team member
□ Documentation: Updated if needed
□ No console errors or debugging statements
```

## Pull Request Process

### Strict Workflow
1. **Feature Branch Complete** - meets all quality gates
2. **Create Pull Request** with comprehensive description
3. **Automated Checks** - CI/CD pipeline must pass
4. **Code Review** - at least one approval required
5. **Address ALL Feedback** - no compromises on quality
6. **Final Validation** - re-run all checks
7. **Squash Merge** - maintain clean history
8. **Delete Branch** - clean up immediately

### Pull Request Template
```markdown
## Description
Brief description of changes

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Breaking change
- [ ] Documentation update

## Quality Checklist
- [ ] Linting passes (0 errors, 0 warnings)
- [ ] All tests pass
- [ ] Coverage requirements met
- [ ] No console errors/warnings
- [ ] Documentation updated

## Testing
- [ ] Unit tests added/updated
- [ ] Integration tests added/updated
- [ ] Manual testing completed

## Screenshots (if applicable)
```

### Merge Strategies
- Use squash merge for feature branches
- Use merge commit for releases
- Use rebase for clean history

```bash
# Clean up history before merge
git rebase -i HEAD~3

# Squash commits during merge
git merge --squash feature/new-feature
```

# Docker Best Practices

## Dockerfile Optimization

### Multi-stage Builds
```dockerfile
# Build stage
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

# Production stage
FROM node:18-alpine AS production
WORKDIR /app
COPY --from=builder /app/node_modules ./node_modules
COPY . .
EXPOSE 3000
CMD ["npm", "start"]
```

### Layer Optimization
- Order layers from least to most frequently changing
- Use .dockerignore to exclude unnecessary files
- Combine RUN commands to reduce layers
- Use specific base image tags

```dockerfile
# Good layer ordering
FROM python:3.11-slim

# Install system dependencies first (changes rarely)
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first (changes less than source code)
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy source code last (changes frequently)
COPY . .

CMD ["python", "app.py"]
```

## Docker Compose

### Development Environment
```yaml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "3000:3000"
    volumes:
      - .:/app
      - /app/node_modules
    environment:
      - NODE_ENV=development
    depends_on:
      - db
      - redis

  db:
    image: postgres:15
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

volumes:
  postgres_data:
```