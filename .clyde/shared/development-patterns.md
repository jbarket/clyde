<!-- Generated by clyde v1.0.0 on 2025-07-30 11:02:40 -->
<!-- Shared Content -->
<!-- Config Hash: ca424fbc -->

# Development Patterns

This file contains shared development standards used by all AI targets.

**⚠ Do not edit this file directly.** Changes will be overwritten.

- To modify standards: Edit `.clyde/config.yaml` and run `clyde sync`

# Iterative Development Patterns

## Core Principle

Iterative development builds complex systems through repeated cycles of incremental improvement, allowing for learning, adaptation, and course correction while maintaining working functionality at each stage.

## When to Apply

- Building complex features with uncertain requirements
- Developing systems where user feedback is critical
- Working with new technologies or unfamiliar domains
- Projects with significant technical risk or complexity
- Long-term development efforts requiring sustained progress

## Development Cycles

### 1. Minimum Viable Implementation (MVI)
Start with simplest version that demonstrates core functionality:
- **Single Use Case**: Address one primary scenario completely
- **Hard-coded Values**: Use constants instead of configuration initially
- **Basic Error Handling**: Handle happy path with minimal error cases
- **Manual Testing**: Verify behavior manually before automation

### 2. Functional Expansion
Add breadth by supporting additional use cases:
- **Parameter Variability**: Replace hard-coded values with inputs
- **Edge Case Handling**: Address boundary conditions
- **Error Recovery**: Improve error handling and user feedback
- **Basic Testing**: Add automated tests for core functionality

### 3. Quality Enhancement
Improve robustness and maintainability:
- **Performance Optimization**: Address measured bottlenecks
- **Security Hardening**: Add authentication, validation, protection
- **Comprehensive Testing**: Expand test coverage and scenarios
- **Documentation**: Add user guides and developer documentation

### 4. Integration and Polish
Connect with broader system and refine user experience:
- **System Integration**: Connect with external services and systems
- **User Experience**: Refine interfaces based on feedback
- **Monitoring**: Add logging, metrics, and alerting
- **Scalability**: Prepare for production load

## Implementation Strategy

### Sprint Planning Approach
```
Iteration 1 (Week 1-2): Core Functionality
- [ ] Basic data model
- [ ] Single API endpoint
- [ ] Manual testing
- [ ] Simple UI mockup

Iteration 2 (Week 3-4): Essential Features
- [ ] Input validation
- [ ] Error handling
- [ ] Database integration
- [ ] Basic automated tests

Iteration 3 (Week 5-6): User Experience
- [ ] Complete UI implementation
- [ ] User feedback integration
- [ ] Performance optimization
- [ ] Security basics

Iteration 4 (Week 7-8): Production Readiness
- [ ] Comprehensive testing
- [ ] Monitoring and logging
- [ ] Documentation
- [ ] Deployment automation
```

### Feature Slicing Techniques

#### Vertical Slicing
Build complete functionality for narrow use cases:
```
E-commerce Example:
Iteration 1: Single product purchase with credit card
Iteration 2: Add inventory checking and out-of-stock handling
Iteration 3: Add multiple payment methods
Iteration 4: Add user accounts and order history
```

#### Horizontal Slicing
Build layers across all features:
```
API Development Example:
Iteration 1: Data models and basic CRUD operations
Iteration 2: Business logic and validation
Iteration 3: Authentication and authorization
Iteration 4: Caching and performance optimization
```

## Examples

### Example 1: User Authentication System

**Iteration 1: Basic Login**
```python
# Simple username/password check
def authenticate_user(username: str, password: str) -> bool:
    # Hard-coded for initial testing
    return username == "admin" and password == "password123"

def login_endpoint():
    username = request.json.get('username')
    password = request.json.get('password')
    
    if authenticate_user(username, password):
        return {"status": "success"}
    else:
        return {"status": "failed"}, 401
```

**Iteration 2: Database Integration**
```python
def authenticate_user(username: str, password: str) -> Optional[User]:
    user = User.query.filter_by(username=username).first()
    if user and check_password_hash(user.password_hash, password):
        return user
    return None

def login_endpoint():
    username = request.json.get('username')
    password = request.json.get('password')
    
    user = authenticate_user(username, password)
    if user:
        session['user_id'] = user.id
        return {"status": "success", "user_id": user.id}
    else:
        return {"status": "failed", "message": "Invalid credentials"}, 401
```

**Iteration 3: Security and Tokens**
```python
import jwt
from datetime import datetime, timedelta

def authenticate_user(username: str, password: str) -> Optional[User]:
    user = User.query.filter_by(username=username).first()
    if user and user.check_password(password):
        user.last_login = datetime.utcnow()
        db.session.commit()
        return user
    return None

def generate_token(user: User) -> str:
    payload = {
        'user_id': user.id,
        'exp': datetime.utcnow() + timedelta(hours=24)
    }
    return jwt.encode(payload, app.config['SECRET_KEY'], algorithm='HS256')

def login_endpoint():
    try:
        username = request.json.get('username')
        password = request.json.get('password')
        
        if not username or not password:
            return {"error": "Username and password required"}, 400
            
        user = authenticate_user(username, password)
        if user:
            token = generate_token(user)
            return {
                "status": "success", 
                "token": token,
                "user": {"id": user.id, "username": user.username}
            }
        else:
            return {"error": "Invalid credentials"}, 401
            
    except Exception as e:
        logger.error(f"Login error: {e}")
        return {"error": "Login failed"}, 500
```

### Example 2: Data Processing Pipeline

**Iteration 1: File Processing**
```python
def process_data_file(filepath: str) -> dict:
    """Process a single CSV file and return summary."""
    import pandas as pd
    
    df = pd.read_csv(filepath)
    return {
        "rows_processed": len(df),
        "columns": list(df.columns),
        "summary": df.describe().to_dict()
    }
```

**Iteration 2: Batch Processing**
```python
def process_data_batch(filepaths: List[str]) -> List[dict]:
    """Process multiple files in sequence."""
    results = []
    
    for filepath in filepaths:
        try:
            result = process_data_file(filepath)
            result["filepath"] = filepath
            result["status"] = "success"
            results.append(result)
        except Exception as e:
            results.append({
                "filepath": filepath,
                "status": "error",
                "error": str(e)
            })
    
    return results
```

**Iteration 3: Async Processing**
```python
import asyncio
import aiofiles

async def process_data_file_async(filepath: str) -> dict:
    """Process file asynchronously."""
    try:
        async with aiofiles.open(filepath, 'r') as f:
            content = await f.read()
        
        df = pd.read_csv(io.StringIO(content))
        return {
            "filepath": filepath,
            "status": "success",
            "rows_processed": len(df),
            "columns": list(df.columns),
            "processing_time": time.time()
        }
    except Exception as e:
        return {
            "filepath": filepath,
            "status": "error",
            "error": str(e)
        }

async def process_data_batch_async(filepaths: List[str]) -> List[dict]:
    """Process files concurrently."""
    tasks = [process_data_file_async(fp) for fp in filepaths]
    results = await asyncio.gather(*tasks)
    return results
```

## Quality Gates

### End-of-Iteration Checklist
```
□ All planned functionality works as expected
□ Code passes all existing tests
□ New tests added for new functionality
□ Code reviewed by team member
□ Documentation updated if needed
□ No critical security vulnerabilities
□ Performance is acceptable for current scale
□ Ready for next iteration's foundation
```

### Iteration Success Criteria
- **Functional**: New capabilities work as designed
- **Testable**: Can be automatically verified
- **Integrated**: Works with existing system components
- **Documented**: Changes are explained and recorded
- **Reviewable**: Code can be understood by team members

## Risk Management

### Technical Debt Tracking
- **Deliberate Shortcuts**: Document decisions to move fast
- **Quality Standards**: Maintain minimum quality bar
- **Refactoring Schedule**: Plan technical debt paydown
- **Metrics Monitoring**: Track code quality trends

### Learning Integration
- **Retrospectives**: Regular reflection on what worked
- **User Feedback**: Incorporate external input early
- **Technical Spikes**: Investigate unknowns before committing
- **Pivot Planning**: Be ready to change direction based on learning

## Anti-patterns to Avoid

- **Big Bang Development**: Trying to build everything at once
- **Feature Creep**: Adding scope without completing current iteration
- **Quality Decay**: Accepting progressively lower quality standards
- **Integration Delay**: Postponing system integration until the end
- **Feedback Avoidance**: Not seeking input until feature is "complete"
- **Perfectionism**: Over-polishing features before validation

## Key Benefits

### Development Velocity
- **Continuous Progress**: Working functionality at each stage
- **Risk Reduction**: Early identification of problems
- **Learning Integration**: Adapt based on real experience
- **Team Morale**: Regular delivery creates positive momentum

### Product Quality
- **User-Centered**: Regular feedback shapes development
- **Robust Architecture**: Incremental building creates solid foundations
- **Better Testing**: Continuous testing catches issues early
- **Maintainable Code**: Regular refactoring prevents technical debt accumulation

## Measurement and Tracking

### Iteration Metrics
- **Velocity**: Story points or features completed per iteration
- **Quality**: Defect rates and technical debt accumulation
- **Learning**: Requirements changes and assumption validation
- **Satisfaction**: Team and stakeholder feedback

### Long-term Indicators
- **Code Quality**: Technical debt and maintainability trends
- **System Stability**: Error rates and performance metrics
- **Development Efficiency**: Time from idea to working feature
- **User Satisfaction**: Adoption and feedback on delivered features

## Scaling Iterative Development

### Team Coordination
- **Synchronized Iterations**: Align team cycles for integration
- **Cross-team Dependencies**: Plan and communicate interdependencies
- **Shared Standards**: Maintain consistent quality and practices
- **Knowledge Sharing**: Regular demos and technical discussions

### System Architecture
- **Modular Design**: Enable independent iteration on components
- **API Contracts**: Stable interfaces between evolving components
- **Feature Flags**: Control rollout of new functionality
- **Monitoring**: Observability for iterative changes in production

# Verification and Validation Patterns

**Core:** Systematic testing ensures code works correctly, meets requirements, behaves predictably.

## Testing Strategies

### Unit Testing
- Single responsibility per test
- Fast, deterministic, independent
- Test behavior, not implementation details

### Integration Testing  
- Validate component interfaces
- Test data flow across boundaries
- Verify error propagation
- Use realistic test environments

### End-to-End Testing
- Test complete user workflows
- Production-like environment
- Real external dependencies
- Full system integration

### Property-Based Testing
- Test invariants vs specific examples
- Generated inputs reveal edge cases
- Automatic boundary condition discovery

## Implementation Patterns

### Unit Test Structure
```python
def test_calculate_total_with_tax():
    # Arrange: Set up test data
    calculator = OrderCalculator(tax_rate=0.08)
    items = [OrderItem(price=10.00, quantity=2)]
    
    # Act: Execute the operation
    total = calculator.calculate_total(items)
    
    # Assert: Verify results
    assert total == 21.60  # $20 + 8% tax
```

### Integration Test Pattern
```python
@pytest.fixture
def database():
    with PostgresContainer("postgres:13") as postgres:
        yield postgres.get_connection_url()

def test_user_creation_flow(database):
    service = UserService(database)
    user = service.create_user({"username": "test"})
    retrieved = service.get_user(user.id)
    assert retrieved.username == "test"
```

## Verification Workflow

### Pre-commit Hooks
- Run unit tests (fast subset)
- Code quality checks (linting, typing)
- Security scans
- Block commits on failures

### CI/CD Pipeline
- Unit tests with coverage
- Integration tests with services
- E2E tests in production-like environment
- Performance benchmarks

## Quality Metrics

### Coverage Analysis
- Line coverage (aim for >80%)
- Branch coverage
- Missing test identification
- Critical path coverage

### Performance Testing
- Response time thresholds
- Load testing under realistic conditions
- Database query performance
- Memory usage monitoring

## Anti-patterns
- Testing implementation details
- Flaky/inconsistent tests
- Slow test suites
- Missing edge cases
- Test dependencies
- Over-mocking

## Benefits
- **Quality:** Bug prevention, regression protection
- **Confidence:** Safe refactoring, reliable deployments  
- **Documentation:** Tests as executable specifications
- **Debugging:** Faster issue isolation and resolution