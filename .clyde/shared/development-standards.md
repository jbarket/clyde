<!-- Generated by clyde v1.0.0 on 2025-07-30 11:02:40 -->
<!-- Shared Content -->
<!-- Config Hash: ca424fbc -->

# Development Standards

This file contains shared development standards used by all AI targets.

**⚠ Do not edit this file directly.** Changes will be overwritten.

- To modify standards: Edit `.clyde/config.yaml` and run `clyde sync`

# Development Standards

## Test-Driven Development (TDD)

### Red-Green-Refactor Cycle
1. **Red**: Write a failing test that describes the desired functionality
2. **Green**: Write the minimal code to make the test pass
3. **Refactor**: Improve the code while keeping tests passing

### Test-First Approach
- Write tests before implementing functionality
- Tests serve as living documentation
- Tests guide design decisions
- Failing tests prevent regressions

## Three-Tier Testing Architecture

### Testing Pyramid Structure
```
                     /\
                    /  \
                   / E2E \  <- Playwright (Headless Only)
                  /______\
                 /        \
                /Integration\ <- Module Boundaries
               /____________\
              /              \
             /   Unit Tests   \ <- Individual Components  
            /________________\
```

### Testing Responsibilities
- **Unit Tests**: Individual pieces and components (80%+ coverage for business logic)
- **Integration Tests**: Module boundaries and external dependencies
- **End-to-End Tests**: Complete user workflows using Playwright (headless)

## Unit Testing Standards

### Test Organization
```
tests/
├── unit/
│   ├── models/
│   ├── services/
│   ├── validators/
│   └── utils/
├── integration/
│   ├── database/
│   ├── api/
│   └── external/
└── e2e/
    ├── auth/
    ├── core-workflows/
    └── accessibility/
```

### Test Quality Requirements
- Tests should be fast, independent, and deterministic
- Mock external dependencies for unit tests
- Test edge cases and error conditions
- Use descriptive test names that explain the scenario
- Follow Arrange-Act-Assert pattern

### Coverage Goals
- **Unit Tests**: 80%+ line coverage for business logic
- **Critical Paths**: 100% coverage (authentication, payments, security)
- **Integration Tests**: Cover all module boundaries
- **E2E Tests**: Cover critical user workflows

### Mocking Strategy
```python
class TestAuthService:
    def setup_method(self):
        # Mock all external dependencies
        self.mock_user_repo = Mock(spec=UserRepository)
        self.mock_password_hasher = Mock(spec=PasswordHasher)
        self.auth_service = AuthService(
            user_repo=self.mock_user_repo,
            password_hasher=self.mock_password_hasher
        )
    
    def test_successful_authentication(self):
        # Arrange
        user = User(id=1, email="test@example.com", is_active=True)
        self.mock_user_repo.find_by_email.return_value = user
        self.mock_password_hasher.verify.return_value = True
        
        # Act
        result = self.auth_service.authenticate("test@example.com", "password")
        
        # Assert
        assert result.success
        assert result.user == user
```

## Integration Testing

### Module Boundary Testing
Integration tests focus on **module boundaries** and **external dependencies**:

```python
class TestUserProductIntegration:
    def setup_method(self):
        # Use real implementations for integration testing
        self.db_session = create_test_database_session()
        self.user_service = UserService(SQLUserRepository(self.db_session))
        self.product_service = ProductService(SQLProductRepository(self.db_session))
    
    def test_user_creation_triggers_product_recommendations(self):
        # Test cross-module integration
        user = self.user_service.create_user({"name": "John", "email": "john@example.com"})
        recommendations = self.product_service.get_welcome_recommendations(user.id)
        assert len(recommendations) > 0
```

## End-to-End Testing with Playwright

### Headless-Only Policy
**Critical Requirement**: All Playwright tests **MUST** run headless

```javascript
// playwright.config.js
module.exports = {
  use: {
    headless: true,  // MANDATORY - never set to false
    video: 'off',    // No visual output
    trace: 'off'     // No trace UI
  },
  projects: [
    {
      name: 'chromium',
      use: { headless: true }  // Enforce headless mode
    }
  ]
};
```

### E2E Test Examples
```javascript
test('should complete user registration workflow', async ({ page }) => {
  // Navigate and complete form
  await page.goto('/register');
  await page.fill('[data-testid="email"]', 'test@example.com');
  await page.fill('[data-testid="password"]', 'SecurePassword123');
  await page.click('[data-testid="register-button"]');
  
  // Verify success
  await expect(page).toHaveURL('/dashboard');
  await expect(page.locator('[data-testid="welcome-message"]')).toBeVisible();
});
```

## Quality Gates

### Pre-Merge Requirements
```bash
□ All unit tests pass (80%+ coverage for business logic)
□ All integration tests pass (module boundaries verified)
□ All E2E tests pass (headless Playwright only)
□ Linting passes with zero errors and warnings
□ No console errors or debugging statements
□ Code review approved
□ Documentation updated if needed
```

### Test Execution Pipeline
```bash
# Development workflow
npm run test:unit           # Fast feedback loop
npm run test:integration    # Module boundaries
npm run test:e2e:headless   # Complete workflows

# CI/CD pipeline
npm run test:all           # All tests must pass
```

### Coverage Thresholds
```json
{
  "coverageThreshold": {
    "global": {
      "branches": 80,
      "functions": 80,
      "lines": 80,
      "statements": 80
    },
    "./src/core/": {
      "branches": 90,
      "functions": 90,
      "lines": 90,
      "statements": 90
    },
    "./src/security/": {
      "branches": 95,
      "functions": 95,
      "lines": 95,
      "statements": 95
    }
  }
}
```

## Test Data Management

### Factory Pattern
```python
class TestDataFactory:
    @staticmethod
    def create_user(overrides=None):
        data = {
            "name": "Test User",
            "email": f"test{random.randint(1000, 9999)}@example.com",
            "password": "SecurePassword123!"
        }
        if overrides:
            data.update(overrides)
        return data
```

## Accessibility Testing
```javascript
// A11y compliance testing
test('should meet WCAG 2.1 standards', async ({ page }) => {
  await page.goto('/');
  const scanResults = await new AxeBuilder({ page }).analyze();
  expect(scanResults.violations).toEqual([]);
});
```

## Performance Testing
```python
def test_operation_performance():
    start_time = time.time()
    result = expensive_operation()
    duration = time.time() - start_time
    
    assert duration < 1.0  # Should complete in less than 1 second
    assert result is not None
```

## Best Practices

### Independent Test Design
- **No shared state** between tests
- **Fresh environment** for each test
- **Deterministic results** - tests should not be flaky
- **Fast execution** - unit tests under 100ms, integration under 1s

### Continuous Testing Integration
```yaml
# CI/CD pipeline
stages:
  - lint
  - unit-tests
  - integration-tests
  - e2e-tests-headless
  - deploy

e2e-tests:
  script:
    - npm run test:e2e:headless  # ALWAYS headless
  artifacts:
    paths:
      - test-results/screenshots/
    when: on_failure
```

# Modular Architecture

## Core Principles

### Single Responsibility
- Each module has one reason to change
- Functions/classes do one thing well
- Separate concerns into distinct modules
- Avoid god objects and utility classes

### High Cohesion, Loose Coupling
- Group related functionality together
- Minimize dependencies between modules
- Use interfaces to define contracts
- Depend on abstractions, not concretions

### DRY Principle Integration
Every piece of knowledge must have single, authoritative representation:
- Configuration centralized
- Business rules have one source of truth
- Extract common code into reusable components
- Use templates/code generation for repetitive patterns

## Domain Separation

### Microservice-Inspired Module Design
Apply domain-driven design principles at module level:
- **Clear domain boundaries** - Each module represents distinct business domain
- **Independent operation** - Modules function independently without tight coupling
- **Explicit interfaces** - All inter-module communication through defined contracts
- **Domain-specific logic** - Business rules contained within appropriate modules

### Domain Boundary Guidelines
```
// Good: Clear domain boundaries
user/
├── models/user.py          # User data structures
├── services/auth.py        # Authentication logic
├── repositories/users.py   # Data access
└── validators/user.py      # Input validation

product/
├── models/product.py       # Product data structures
├── services/catalog.py     # Business logic
├── repositories/products.py # Data access
└── events/product.py       # Domain events
```

### Avoid Shared Everything
```
// Bad: Shared utilities become coupling points
shared/utils.py               # Everything in one place

// Good: Domain-specific utilities
user/utils/user_helpers.py    # User-specific utilities 
product/utils/pricing.py      # Product-specific utilities
```

## Module Organization

### Directory Structure
- Organize by feature, not by type
- Use consistent naming conventions
- Keep related files together
- Separate concerns clearly

```
project/
├── user/
│   ├── models.py
│   ├── services.py
│   └── views.py
├── product/
│   ├── models.py
│   └── services.py
└── shared/
    ├── utils.py
    └── exceptions.py
```

### Import Management
- Use explicit imports over wildcard imports
- Import at module level
- Avoid circular imports
- Group imports logically (standard, third-party, local)

## Interface Design

### Define Clear Contracts
```python
from abc import ABC, abstractmethod

class UserRepository(ABC):
    @abstractmethod
    def find_by_id(self, user_id: str) -> Optional[User]:
        pass
    
    @abstractmethod
    def save(self, user: User) -> User:
        pass

class UserService:
    def __init__(self, user_repo: UserRepository):
        self._user_repo = user_repo
    
    def authenticate_user(self, email: str, password: str) -> Optional[User]:
        user = self._user_repo.find_by_email(email)
        if user and user.verify_password(password):
            return user
        return None
```

### Module Communication Patterns
```python
# Event-driven communication between modules
class UserCreatedEvent:
    def __init__(self, user_id: str, email: str):
        self.user_id = user_id
        self.email = email
        self.timestamp = datetime.utcnow()

class UserService:
    def create_user(self, user_data: dict) -> User:
        user = User(**user_data)
        saved_user = self._user_repo.save(user)
        
        # Notify other modules without tight coupling
        self._event_bus.publish(UserCreatedEvent(
            user_id=saved_user.id,
            email=saved_user.email
        ))
        
        return saved_user
```

## AI-Agent-Friendly Design

### File and Function Sizing Guidelines
```python
# Optimal sizes for AI reasoning
- **Functions**: 10-30 lines (readable in single view)
- **Classes**: 50-150 lines (comprehensible as unit)
- **Modules**: 200-500 lines (fits in context window)
- **Files**: Maximum 800 lines (AI can process entirely)
```

### Self-Explaining Code Structure
```python
# Good: Names that explain purpose and context
def send_welcome_email_to_new_user(user: User, email_template: EmailTemplate) -> EmailResult:
    pass

def calculate_monthly_subscription_renewal_date(subscription: Subscription) -> datetime:
    pass

# Avoid: Abbreviated or unclear names
def send_email(u, t):  # Unclear parameters
def calc_date(s):      # Abbreviated and unclear
```

### Consistent Code Organization
```python
"""
Module: user_service.py
Purpose: User-related business logic and operations
"""

# 1. Imports (grouped logically)
from typing import Optional, List
from datetime import datetime

# 2. Constants and configuration
MAX_LOGIN_ATTEMPTS = 3
PASSWORD_MIN_LENGTH = 8

# 3. Data classes and types
@dataclass
class UserCreationRequest:
    email: str
    password: str
    full_name: str

# 4. Main class implementation
class UserService:
    """Service class for user-related operations."""
    
    def __init__(self, user_repository: UserRepository):
        self._user_repository = user_repository
    
    # Public methods first
    def create_user(self, request: UserCreationRequest) -> User:
        """Create a new user account."""
        self._validate_user_creation_request(request)
        
        user = User(
            email=request.email,
            password_hash=self._hash_password(request.password),
            full_name=request.full_name,
            created_at=datetime.utcnow()
        )
        
        return self._user_repository.save(user)
    
    # Private methods last
    def _validate_user_creation_request(self, request: UserCreationRequest) -> None:
        """Validate user creation request data."""
        if not self._is_valid_email(request.email):
            raise ValidationError("Invalid email format")
```

## Design Patterns

### Dependency Injection
- Pass dependencies as parameters
- Use dependency injection containers when appropriate
- Make dependencies explicit and testable
- Avoid hidden dependencies

```python
# Good: Explicit dependency injection
class OrderService:
    def __init__(self, payment_processor: PaymentProcessor, email_service: EmailService):
        self._payment_processor = payment_processor
        self._email_service = email_service
```

### Interface Segregation
- Create focused interfaces
- Clients shouldn't depend on methods they don't use
- Use abstract base classes or protocols
- Keep interfaces stable

### Plugin Architecture
- Design for extensibility
- Use configuration-driven behavior
- Support runtime module loading
- Provide clear extension points

## Independent Testability

### Module-Level Test Isolation
```python
# Each module should be testable in isolation
class TestUserService:
    def setup_method(self):
        # Mock all external dependencies
        self.mock_user_repo = Mock(spec=UserRepository)
        self.mock_event_bus = Mock(spec=EventBus)
        self.user_service = UserService(
            self.mock_user_repo,
            self.mock_event_bus
        )
    
    def test_create_user_success(self):
        # Test only the user service logic
        user_data = {"name": "John", "email": "john@example.com"}
        expected_user = User(**user_data)
        self.mock_user_repo.save.return_value = expected_user
        
        result = self.user_service.create_user(user_data)
        
        assert result == expected_user
        self.mock_event_bus.publish.assert_called_once()
```

## Configuration and Dependencies

### Module Configuration
```python
# Each module manages its own configuration
class UserModuleConfig:
    def __init__(self):
        self.password_min_length = int(os.getenv('USER_PASSWORD_MIN_LENGTH', '8'))
        self.session_timeout = int(os.getenv('USER_SESSION_TIMEOUT', '3600'))
        self.enable_2fa = os.getenv('USER_ENABLE_2FA', 'false').lower() == 'true'
```

### Dependency Injection Container
```python
class DIContainer:
    def __init__(self):
        self._services = {}
    
    def register(self, interface, implementation):
        self._services[interface] = implementation
    
    def get(self, interface):
        return self._services[interface]

# Module registration
def configure_user_module(container: DIContainer):
    container.register(UserRepository, SQLUserRepository())
    container.register(UserService, UserService(
        container.get(UserRepository),
        container.get(EventBus)
    ))
```

## Module Design Checklist
```bash
□ Single responsibility - module has one reason to change
□ Clear boundaries - explicit interfaces and contracts
□ Independent testing - can be tested without other modules
□ Minimal coupling - depends only on necessary abstractions
□ Explicit dependencies - all dependencies are injected
□ Domain-specific - utilities and helpers are module-specific
□ Event-driven communication - loose coupling between modules
□ AI-friendly sizing - files and functions within optimal ranges
```

## Anti-Patterns to Avoid

- **God modules** that handle multiple domains
- **Shared mutable state** between modules
- **Circular dependencies** between modules
- **Leaky abstractions** that expose implementation details
- **Tight coupling** through direct imports of concrete classes
- **Cross-module database queries** that bypass interfaces
- **Shared utility classes** that create hidden dependencies

## Key Benefits

### Development Benefits
- **Faster development** - teams work independently on modules
- **Easier reasoning** - smaller, focused codebases per module
- **Reduced merge conflicts** - changes isolated to specific modules
- **Better testing** - isolated unit tests and focused integration tests
- **AI collaboration** - modules sized for AI context windows

### Maintenance Benefits
- **Easier debugging** - issues confined to specific domains
- **Safer refactoring** - changes contained within module boundaries
- **Incremental upgrades** - modules can evolve independently
- **Technical debt isolation** - problems don't spread across domains